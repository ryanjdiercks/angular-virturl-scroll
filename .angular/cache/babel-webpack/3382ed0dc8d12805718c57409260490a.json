{"ast":null,"code":"import _asyncToGenerator from \"/Volumes/Data/on-going/ryan/angular-virturl-scroll/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Observable, Subject } from \"rxjs\";\nimport { debounceTime, filter } from \"rxjs/operators\";\nexport var IntersectionStatus;\n\n(function (IntersectionStatus) {\n  IntersectionStatus[\"Visible\"] = \"Visible\";\n  IntersectionStatus[\"Pending\"] = \"Pending\";\n  IntersectionStatus[\"NotVisible\"] = \"NotVisible\";\n})(IntersectionStatus || (IntersectionStatus = {}));\n\nexport const fromIntersectionObserver = (element, config, debounce = 0) => new Observable(subscriber => {\n  const subject$ = new Subject();\n  const intersectionObserver = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      if (isIntersecting(entry)) {\n        subject$.next({\n          entry,\n          observer\n        });\n      }\n    });\n  }, config);\n  subject$.subscribe(() => {\n    subscriber.next(IntersectionStatus.Pending);\n  });\n  subject$.pipe(debounceTime(debounce), filter(Boolean)).subscribe( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* ({\n      entry,\n      observer\n    }) {\n      const isEntryVisible = yield isVisible(entry.target);\n\n      if (isEntryVisible) {\n        subscriber.next(IntersectionStatus.Visible);\n        observer.unobserve(entry.target);\n      } else {\n        subscriber.next(IntersectionStatus.NotVisible);\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  intersectionObserver.observe(element);\n  return {\n    unsubscribe() {\n      intersectionObserver.disconnect();\n      subject$.unsubscribe();\n    }\n\n  };\n});\n\nfunction isVisible(_x2) {\n  return _isVisible.apply(this, arguments);\n}\n\nfunction _isVisible() {\n  _isVisible = _asyncToGenerator(function* (element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        resolve(entry.isIntersecting);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  });\n  return _isVisible.apply(this, arguments);\n}\n\nfunction isIntersecting(entry) {\n  return entry.isIntersecting || entry.intersectionRatio > 0;\n}","map":{"version":3,"sources":["/Volumes/Data/on-going/ryan/angular-virturl-scroll/src/app/from-intersection-observer.ts"],"names":["Observable","Subject","debounceTime","filter","IntersectionStatus","fromIntersectionObserver","element","config","debounce","subscriber","subject$","intersectionObserver","IntersectionObserver","entries","observer","forEach","entry","isIntersecting","next","subscribe","Pending","pipe","Boolean","isEntryVisible","isVisible","target","Visible","unobserve","NotVisible","observe","unsubscribe","disconnect","Promise","resolve","intersectionRatio"],"mappings":";AAAA,SAASA,UAAT,EAAqBC,OAArB,QAAoC,MAApC;AACA,SAASC,YAAT,EAAuBC,MAAvB,QAAqC,gBAArC;AACA,OAAO,IAAIC,kBAAJ;;AACP,CAAC,UAAUA,kBAAV,EAA8B;AAC3BA,EAAAA,kBAAkB,CAAC,SAAD,CAAlB,GAAgC,SAAhC;AACAA,EAAAA,kBAAkB,CAAC,SAAD,CAAlB,GAAgC,SAAhC;AACAA,EAAAA,kBAAkB,CAAC,YAAD,CAAlB,GAAmC,YAAnC;AACH,CAJD,EAIGA,kBAAkB,KAAKA,kBAAkB,GAAG,EAA1B,CAJrB;;AAKA,OAAO,MAAMC,wBAAwB,GAAG,CAACC,OAAD,EAAUC,MAAV,EAAkBC,QAAQ,GAAG,CAA7B,KAAmC,IAAIR,UAAJ,CAAeS,UAAU,IAAI;AACpG,QAAMC,QAAQ,GAAG,IAAIT,OAAJ,EAAjB;AACA,QAAMU,oBAAoB,GAAG,IAAIC,oBAAJ,CAAyB,CAACC,OAAD,EAAUC,QAAV,KAAuB;AACzED,IAAAA,OAAO,CAACE,OAAR,CAAgBC,KAAK,IAAI;AACrB,UAAIC,cAAc,CAACD,KAAD,CAAlB,EAA2B;AACvBN,QAAAA,QAAQ,CAACQ,IAAT,CAAc;AAAEF,UAAAA,KAAF;AAASF,UAAAA;AAAT,SAAd;AACH;AACJ,KAJD;AAKH,GAN4B,EAM1BP,MAN0B,CAA7B;AAOAG,EAAAA,QAAQ,CAACS,SAAT,CAAmB,MAAM;AACrBV,IAAAA,UAAU,CAACS,IAAX,CAAgBd,kBAAkB,CAACgB,OAAnC;AACH,GAFD;AAGAV,EAAAA,QAAQ,CACHW,IADL,CACUnB,YAAY,CAACM,QAAD,CADtB,EACkCL,MAAM,CAACmB,OAAD,CADxC,EAEKH,SAFL;AAAA,iCAEe,WAAO;AAAEH,MAAAA,KAAF;AAASF,MAAAA;AAAT,KAAP,EAA+B;AAC1C,YAAMS,cAAc,SAASC,SAAS,CAACR,KAAK,CAACS,MAAP,CAAtC;;AACA,UAAIF,cAAJ,EAAoB;AAChBd,QAAAA,UAAU,CAACS,IAAX,CAAgBd,kBAAkB,CAACsB,OAAnC;AACAZ,QAAAA,QAAQ,CAACa,SAAT,CAAmBX,KAAK,CAACS,MAAzB;AACH,OAHD,MAIK;AACDhB,QAAAA,UAAU,CAACS,IAAX,CAAgBd,kBAAkB,CAACwB,UAAnC;AACH;AACJ,KAXD;;AAAA;AAAA;AAAA;AAAA;AAYAjB,EAAAA,oBAAoB,CAACkB,OAArB,CAA6BvB,OAA7B;AACA,SAAO;AACHwB,IAAAA,WAAW,GAAG;AACVnB,MAAAA,oBAAoB,CAACoB,UAArB;AACArB,MAAAA,QAAQ,CAACoB,WAAT;AACH;;AAJE,GAAP;AAMH,CA/B0E,CAApE;;SAgCQN,S;;;;;iCAAf,WAAyBlB,OAAzB,EAAkC;AAC9B,WAAO,IAAI0B,OAAJ,CAAYC,OAAO,IAAI;AAC1B,YAAMnB,QAAQ,GAAG,IAAIF,oBAAJ,CAAyB,CAAC,CAACI,KAAD,CAAD,KAAa;AACnDiB,QAAAA,OAAO,CAACjB,KAAK,CAACC,cAAP,CAAP;AACAH,QAAAA,QAAQ,CAACiB,UAAT;AACH,OAHgB,CAAjB;AAIAjB,MAAAA,QAAQ,CAACe,OAAT,CAAiBvB,OAAjB;AACH,KANM,CAAP;AAOH,G;;;;AACD,SAASW,cAAT,CAAwBD,KAAxB,EAA+B;AAC3B,SAAOA,KAAK,CAACC,cAAN,IAAwBD,KAAK,CAACkB,iBAAN,GAA0B,CAAzD;AACH","sourcesContent":["import { Observable, Subject } from \"rxjs\";\nimport { debounceTime, filter } from \"rxjs/operators\";\nexport var IntersectionStatus;\n(function (IntersectionStatus) {\n    IntersectionStatus[\"Visible\"] = \"Visible\";\n    IntersectionStatus[\"Pending\"] = \"Pending\";\n    IntersectionStatus[\"NotVisible\"] = \"NotVisible\";\n})(IntersectionStatus || (IntersectionStatus = {}));\nexport const fromIntersectionObserver = (element, config, debounce = 0) => new Observable(subscriber => {\n    const subject$ = new Subject();\n    const intersectionObserver = new IntersectionObserver((entries, observer) => {\n        entries.forEach(entry => {\n            if (isIntersecting(entry)) {\n                subject$.next({ entry, observer });\n            }\n        });\n    }, config);\n    subject$.subscribe(() => {\n        subscriber.next(IntersectionStatus.Pending);\n    });\n    subject$\n        .pipe(debounceTime(debounce), filter(Boolean))\n        .subscribe(async ({ entry, observer }) => {\n        const isEntryVisible = await isVisible(entry.target);\n        if (isEntryVisible) {\n            subscriber.next(IntersectionStatus.Visible);\n            observer.unobserve(entry.target);\n        }\n        else {\n            subscriber.next(IntersectionStatus.NotVisible);\n        }\n    });\n    intersectionObserver.observe(element);\n    return {\n        unsubscribe() {\n            intersectionObserver.disconnect();\n            subject$.unsubscribe();\n        }\n    };\n});\nasync function isVisible(element) {\n    return new Promise(resolve => {\n        const observer = new IntersectionObserver(([entry]) => {\n            resolve(entry.isIntersecting);\n            observer.disconnect();\n        });\n        observer.observe(element);\n    });\n}\nfunction isIntersecting(entry) {\n    return entry.isIntersecting || entry.intersectionRatio > 0;\n}\n"]},"metadata":{},"sourceType":"module"}